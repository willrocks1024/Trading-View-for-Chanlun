//接下来你要从左到右，对经过合并处理后的K线图，把顶分型的最高点和底分型的最低点连成笔，具体逻辑如下：
//1. 从左到右找出第一个顶分型或者底分型，然后往右筛选下一个分型
//2. 如果n-1分型是顶分型，则n分型必须是底分型或者高点更高的顶分型，并且n-1分型和n分型的连线至少有5条合并处理后的k线，否则就忽略该n分型，寻找下一个分型作为n分型
//3. 如果n-1分型是底分型，则n分型必须是顶分型或者低点更低的底分型，并且n-1分型和n分型的连线至少有5条合并处理后的k线，否则就忽略该n分型，寻找下一个分型作为n分型
//4. 对笔的方向进行区分，从左到右的笔如果是底分型连到底分型，或者顶分型连到底分型，称为下降笔，用蓝色的线标记；从左到右如果是顶分型连到顶分型，或者底分型连到顶分型，称为上升笔，用橙色的线标记

//@version=6
indicator("合并K线与分型标记（含方向判断+成笔）", overlay=true)

// 模拟结构体的多个数组
var openArr  = array.new_float()
var highArr  = array.new_float()
var lowArr   = array.new_float()
var closeArr = array.new_float()
var timeArr  = array.new_int()

// 存储分型信息
var fractalIndexes = array.new_int()
var fractalPrices  = array.new_float()
var fractalTimes   = array.new_int()
var fractalTypes   = array.new_int()   // 顶=1，底=-1

// 当前合并K线状态
var float curOpen  = na
var float curHigh  = na
var float curLow   = na
var float curClose = na
var int   curTime  = na

// 判断包含关系
isInside(ph, pl, ch, cl) =>
    (ch <= ph and cl >= pl) or (ch >= ph and cl <= pl)

// 获取方向：向左寻找最近非包含K线
getMergeDirection(float curHigh, float curLow) =>
    int len = array.size(highArr)
    int dir = 0
    if len > 0
        for i = len - 1 to 0
            float prevHigh = array.get(highArr, i)
            float prevLow  = array.get(lowArr, i)
            bool notInside = not isInside(prevHigh, prevLow, curHigh, curLow)
            if notInside
                dir := curHigh > prevHigh ? 1 : -1
                break
    dir

// 合并K线逻辑
if bar_index == 0
    curOpen  := open
    curHigh  := high
    curLow   := low
    curClose := close
    curTime  := time
else
    if isInside(curHigh, curLow, high, low)
        dir = getMergeDirection(curHigh, curLow)
        if dir == -1
            curHigh := math.min(curHigh, high)
            curLow  := math.min(curLow, low)
        else if dir == 1
            curHigh := math.max(curHigh, high)
            curLow  := math.max(curLow, low)
        curClose := close
    else
        // 推入数组
		array.push(openArr,  curOpen)
        array.push(highArr,  curHigh)
        array.push(lowArr,   curLow)
        array.push(closeArr, curClose)
        array.push(timeArr,  curTime)

        // 重新初始化
		curOpen  := open
        curHigh  := high
        curLow   := low
        curClose := close
        curTime  := time

// 最后一根bar时，推入当前合并K线，并处理分型与连线
if barstate.islast
    array.push(openArr,  curOpen)
    array.push(highArr,  curHigh)
    array.push(lowArr,   curLow)
    array.push(closeArr, curClose)
    array.push(timeArr,  curTime)

    array.clear(fractalIndexes)
    array.clear(fractalPrices)
    array.clear(fractalTimes)
    array.clear(fractalTypes)

    for i = 1 to array.size(openArr) - 2
        float lh = array.get(highArr, i - 1)
        float ch = array.get(highArr, i)
        float rh = array.get(highArr, i + 1)

        float ll = array.get(lowArr, i - 1)
        float cl = array.get(lowArr, i)
        float rl = array.get(lowArr, i + 1)

        int t = array.get(timeArr, i)
        float h = array.get(highArr, i)
        float l = array.get(lowArr, i)

        // 确保三根K线互不包含
		noContain = not isInside(lh, ll, ch, cl) and not isInside(ch, cl, rh, rl)

        if noContain
            isTop = ch > lh and ch > rh and cl > ll and cl > rl
            isDown = ch < lh and ch < rh and cl < ll and cl < rl

            if isTop
                label.new(t, h, "Top", style=label.style_label_down, color=color.red, textcolor=color.white, xloc=xloc.bar_time)
                array.push(fractalIndexes, i)
                array.push(fractalPrices, h)
                array.push(fractalTimes, t)
                array.push(fractalTypes, 1)

            if isDown
                label.new(t, l, "Down", style=label.style_label_up, color=color.green, textcolor=color.white, xloc=xloc.bar_time)
                array.push(fractalIndexes, i)
                array.push(fractalPrices, l)
                array.push(fractalTimes, t)
                array.push(fractalTypes, -1)

    // ---------- 连线成笔并标记方向 ----------
    MIN_GAP = 4
    if array.size(fractalIndexes) >= 2
        int i = 0
        while i < array.size(fractalIndexes) - 1
            int idxA   = array.get(fractalIndexes, i)
            float pxA  = array.get(fractalPrices, i)
            int timeA  = array.get(fractalTimes, i)
            int typeA  = array.get(fractalTypes, i)

            int j = i + 1
            bool found = false
            while j < array.size(fractalIndexes)
                int idxB   = array.get(fractalIndexes, j)
                float pxB  = array.get(fractalPrices, j)
                int timeB  = array.get(fractalTimes, j)
                int typeB  = array.get(fractalTypes, j)

                bool valid =
                  (idxB - idxA >= MIN_GAP) and (
                      (typeA == 1 and (typeB == -1 or pxB > pxA)) or
                      (typeA == -1 and (typeB == 1 or pxB < pxA))
                  )

                if valid
                    bool isDownPen = (typeA == -1 and typeB == -1) or (typeA == 1 and typeB == -1)
                    bool isUpPen   = (typeA == 1 and typeB == 1) or (typeA == -1 and typeB == 1)

                    color penColor = isDownPen ? color.blue : isUpPen ? color.orange : color.gray
                    line.new(timeA, pxA, timeB, pxB, color=penColor, width=2, xloc=xloc.bar_time)

                    found := true
                    break
                j += 1

            if found
                i := j
            else
                i += 1
