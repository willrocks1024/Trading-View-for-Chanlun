//对于上述包含关系处理的代码需要修改并新增以下判断和逻辑处理
//1. 如果两根k线是包含关系，要往左寻找最近一根非包含K线，如果这条非包含k线的高点大于下一根k线的高点，则判断这两根包含关系的K线合并方向向下；如果这条非包含k线的高点小于下一根k线的高点，则判断这两根包含关系的K线合并方向向上
//2. 对于合并方向向下的两根包含关系的k线，取两根k线的高点最小值和低点最小值
//3. 对于合并方向向上的两根包含关系的k线，取两根k线的高点最大值和低点最大值
//4. 展示合并K线，发现代码用包含关系右边那根k线和左边没包含关系的k线进行方向判断，修改方向判断逻辑

//@version=6
indicator("合并K线与分型标记（含方向判断）", overlay=true)

// 模拟结构体的多个数组
var openArr  = array.new_float()
var highArr  = array.new_float()
var lowArr   = array.new_float()
var closeArr = array.new_float()
var timeArr  = array.new_int()

// 当前合并K线状态
var float curOpen  = na
var float curHigh  = na
var float curLow   = na
var float curClose = na
var int   curTime  = na

// 判断是否包含关系
isInside(ph, pl, ch, cl) =>
    (ch <= ph and cl >= pl) or (ch >= ph and cl <= pl)

// 获取方向：向左寻找最近一根非包含K线
getMergeDirection(float curHigh, float curLow) =>
    int len = array.size(highArr)
    int dir = 0
    if len > 0
        for i = len - 1 to 0
            float prevHigh = array.get(highArr, i)
            float prevLow  = array.get(lowArr, i)
            bool notInside = not isInside(prevHigh, prevLow, curHigh, curLow)
            if notInside
                dir := curHigh > prevHigh ? 1 : -1
                break
    dir
	
// 颜色设置（可自定义）
mergeColor = color.new(color.orange, 85)  // 半透明橙色，85 表示透明度

// 合并K线逻辑
if bar_index == 0
    curOpen  := open
    curHigh  := high
    curLow   := low
    curClose := close
    curTime  := time
else
    if isInside(curHigh, curLow, high, low)
        dir = getMergeDirection(curHigh, curLow)
        if dir == -1
            curHigh := math.min(curHigh, high)
            curLow  := math.min(curLow, low)
        else if dir == 1
            curHigh := math.max(curHigh, high)
            curLow  := math.max(curLow, low)
        curClose := close
    else
	    // 可视化：绘制合并K线框
        box.new(left = curTime,right = time,top = curHigh,bottom = curLow,bgcolor = mergeColor,border_color = na,xloc = xloc.bar_time)
		
		// 推入数组
        array.push(openArr,  curOpen)
        array.push(highArr,  curHigh)
        array.push(lowArr,   curLow)
        array.push(closeArr, curClose)
        array.push(timeArr,  curTime)

        // 重新初始化
        curOpen  := open
        curHigh  := high
        curLow   := low
        curClose := close
        curTime  := time

// 最后一根bar时，推入当前合并K线
if barstate.islast
    array.push(openArr,  curOpen)
    array.push(highArr,  curHigh)
    array.push(lowArr,   curLow)
    array.push(closeArr, curClose)
    array.push(timeArr,  curTime)

// 标记顶底分型（需要至少3根合并K线）
if array.size(openArr) >= 3
    for i = 1 to array.size(openArr) - 2
        float lh = array.get(highArr, i - 1)
        float ch = array.get(highArr, i)
        float rh = array.get(highArr, i + 1)

        float ll = array.get(lowArr, i - 1)
        float cl = array.get(lowArr, i)
        float rl = array.get(lowArr, i + 1)

        int t = array.get(timeArr, i)
        float h = array.get(highArr, i)
        float l = array.get(lowArr, i)

        // 确保三根K线互不包含
        noContain = not isInside(lh, ll, ch, cl) and not isInside(ch, cl, rh, rl)

        if noContain
            isTop = ch > lh and ch > rh and cl > ll and cl > rl
            isDown = ch < lh and ch < rh and cl < ll and cl < rl

            if isTop
                label.new(t, h, "Top", style=label.style_label_down, color=color.red, textcolor=color.white, xloc=xloc.bar_time)

            if isDown
                label.new(t, l, "Down", style=label.style_label_up, color=color.green, textcolor=color.white, xloc=xloc.bar_time)
